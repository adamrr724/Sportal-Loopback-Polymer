/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
"use strict";
const dom5 = require('dom5');
const parse5 = require('parse5');
const path = require('path');
const logging = require('plylog');
const stream_1 = require('stream');
let logger = logging.getLogger('cli.build.prefech');
class PrefetchTransform extends stream_1.Transform {
    constructor(
        /**
         * Root of the dependencies.
         * Will be stripped when making links
         */
        root, 
        /**
         * The main HTML file. This will have link rel=prefetches added to it.
         */
        entrypoint, 
        /**
         * The app shell. This will have link rel=imports added to it.
         */
        shell, 
        /**
         * List of files that will have dependencies flattened with
         * `<link rel="import">`
         */
        fragments, 
        /**
         * The analyzer to retreive dependency information from.
         */
        analyzer) {
        super({ objectMode: true });
        this.root = root;
        this.entrypoint = entrypoint;
        this.shell = shell;
        this.fragments = fragments;
        // clone fragments
        this.allFragments = Array.from(fragments);
        if (shell) {
            this.allFragments.push(shell);
        }
        else {
            this.allFragments.push(entrypoint);
        }
        this.analyzer = analyzer;
        this.fileMap = new Map();
    }
    pullUpDeps(file, deps, type) {
        let contents = file.contents.toString();
        let ast = parse5.parse(contents);
        let head = dom5.query(ast, dom5.predicates.hasTagName('head'));
        for (let dep of deps) {
            if (dep.startsWith(this.root)) {
                dep = path.relative(file.dirname, dep);
            }
            // prefetched deps should be absolute, as they will be in the main file
            if (type === 'prefetch') {
                dep = path.join('/', dep);
            }
            let link = dom5.constructors.element('link');
            dom5.setAttribute(link, 'rel', type);
            dom5.setAttribute(link, 'href', dep);
            dom5.append(head, link);
        }
        contents = parse5.serialize(ast);
        file.contents = new Buffer(contents);
    }
    _transform(file, _encoding, callback) {
        if (this.isImportantFile(file)) {
            // hold on to the file for safe keeping
            this.fileMap.set(file.path, file);
            callback(null, null);
        }
        else {
            callback(null, file);
        }
    }
    isImportantFile(file) {
        return file.path === this.entrypoint ||
            this.allFragments.indexOf(file.path) > -1;
    }
    _flush(done) {
        if (this.fileMap.size === 0) {
            return done();
        }
        this.analyzer.analyzeDependencies.then((depsIndex) => {
            let fragmentToDeps = new Map(depsIndex.fragmentToDeps);
            if (this.entrypoint && this.shell) {
                let file = this.fileMap.get(this.entrypoint);
                // forward shell's dependencies to main to be prefetched
                let deps = fragmentToDeps.get(this.shell);
                if (deps) {
                    this.pullUpDeps(file, deps, 'prefetch');
                }
                this.push(file);
                this.fileMap.delete(this.entrypoint);
            }
            for (let im of this.allFragments) {
                let file = this.fileMap.get(im);
                let deps = fragmentToDeps.get(im);
                if (deps) {
                    this.pullUpDeps(file, deps, 'import');
                }
                this.push(file);
                this.fileMap.delete(im);
            }
            for (let leftover of this.fileMap.keys()) {
                logger.warn('File was listed in fragments but not found in stream:', leftover);
                this.push(this.fileMap.get(leftover));
                this.fileMap.delete(leftover);
            }
            done();
        });
    }
}
exports.PrefetchTransform = PrefetchTransform;
